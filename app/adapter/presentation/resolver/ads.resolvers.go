package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"

	"github.com/yuorei/video-server/app/domain"
	model "github.com/yuorei/video-server/app/domain/models"
)

// WatchCountAdVideo is the resolver for the watchCountAdVideo field.
func (r *mutationResolver) WatchCountAdVideo(ctx context.Context, input model.WatchCountAdVideoInput) (*model.WatchCountAdVideoPayload, error) {
	ipInfomation, err := r.usecase.IPInputPort.IPInfomation(ctx, input.IPAddress)
	if err != nil {
		return nil, err
	}
	watchCountAdVideoRequest := &domain.WatchCountAdVideoRequest{
		UserAgent:            input.UserAgent,
		Platform:             input.Platform,
		Language:             input.Language,
		URL:                  input.URL,
		PageTitle:            input.PageTitle,
		Referrer:             *input.Referrer,
		NetworkDownlink:      *input.NetworkDownlink,
		NetworkEffectiveType: *input.NetworkEffectiveType,
		IPAddress:            ipInfomation.IP,
		Location:             ipInfomation.Loc,
		Hostname:             ipInfomation.Hostname,
		City:                 ipInfomation.City,
		Region:               ipInfomation.Region,
		Country:              ipInfomation.Country,
		Org:                  ipInfomation.Org,
		Postal:               ipInfomation.Postal,
		Timezone:             ipInfomation.Timezone,
		VideoID:              input.VideoID,
		Title:                input.Title,
		Description:          &input.Description,
		Tags:                 input.Tags,
		UserID:               input.UserID,
		ClientID:             input.ClientID,
		AdID:                 input.AdID,
	}

	err = r.usecase.WatchCountAdVideo(ctx, watchCountAdVideoRequest)
	if err != nil {
		return &model.WatchCountAdVideoPayload{Success: false}, err
	}

	return &model.WatchCountAdVideoPayload{Success: true}, nil
}

// AdVideo is the resolver for the AdVideo field.
func (r *queryResolver) AdVideo(ctx context.Context, input model.AdVideoInput) ([]*model.AdVideoPayload, error) {
	ipInfomation, err := r.usecase.IPInputPort.IPInfomation(ctx, input.IPAddress)
	if err != nil {
		return nil, err
	}
	// TODO: 関連した広告を取るために動画情報を取得する
	title := ""
	description := ""
	tags := []string{}
	if input.Referrer == nil {
		input.Referrer = new(string)
	}
	if input.NetworkDownlink == nil {
		input.NetworkDownlink = new(string)
	}
	if input.NetworkEffectiveType == nil {
		input.NetworkEffectiveType = new(string)
	}
	adVideoRequest := domain.NewAdVideoRequest(
		input.UserAgent,
		input.Platform,
		input.Language,
		input.URL,
		input.PageTitle,
		*input.Referrer,
		*input.NetworkDownlink,
		*input.NetworkEffectiveType,
		ipInfomation.IP,
		ipInfomation.Loc,
		ipInfomation.Hostname,
		ipInfomation.City,
		ipInfomation.Region,
		ipInfomation.Country,
		ipInfomation.Org,
		ipInfomation.Postal,
		ipInfomation.Timezone,
		input.VideoID,
		title,
		input.UserID,
		input.ClientID,
		&description,
		tags)
	ads, err := r.usecase.AdInputPort.GetAdsByVideoID(ctx, adVideoRequest)
	if err != nil {
		return nil, err
	}

	adsResponse := make([]*model.AdVideoPayload, 0)
	for _, ad := range ads {
		adsResponse = append(adsResponse, &model.AdVideoPayload{
			AdID:         ad.ID,
			AdURL:        ad.AdURL,
			Title:        ad.Title,
			Description:  ad.Description,
			ThumbnailURL: ad.ThumbnailURL,
			VideoURL:     ad.VideoURL,
		})
	}

	return adsResponse, nil
}
