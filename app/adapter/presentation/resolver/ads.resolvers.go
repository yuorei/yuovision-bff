package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"

	"github.com/yuorei/video-server/app/domain"
	model "github.com/yuorei/video-server/app/domain/models"
)

// WatchCountAdVideo is the resolver for the watchCountAdVideo field.
func (r *mutationResolver) WatchCountAdVideo(ctx context.Context, input model.WatchCountAdVideoInput) (bool, error) {
	watchCountAdVideoRequest := &domain.WatchCountAdVideoRequest{
		UserAgent:            input.UserAgent,
		Platform:             input.Platform,
		Language:             input.Language,
		URL:                  input.URL,
		PageTitle:            input.PageTitle,
		Referrer:             *input.Referrer,
		NetworkDownlink:      *input.NetworkDownlink,
		NetworkEffectiveType: *input.NetworkEffectiveType,
		IPAddress:            input.IPAddress,
		Location:             input.Location,
		Hostname:             input.Hostname,
		City:                 input.City,
		Region:               input.Region,
		Country:              input.Country,
		Org:                  input.Org,
		Postal:               input.Postal,
		Timezone:             input.Timezone,
		VideoID:              input.VideoID,
		Title:                input.Title,
		Description:          &input.Description,
		Tags:                 input.Tags,
		UserID:               input.UserID,
		ClientID:             input.ClientID,
		AdID:                 input.AdID,
	}

	err := r.usecase.WatchCountAdVideo(ctx, watchCountAdVideoRequest)
	if err != nil {
		return false, err
	}

	return true, nil
}

// AdVideo is the resolver for the AdVideo field.
func (r *queryResolver) AdVideo(ctx context.Context, input model.AdVideoInput) ([]*model.AdVideoPayload, error) {
	// TODO: 関連した広告を取るために動画情報を取得する
	title := ""
	description := ""
	tags := []string{}
	adVideoRequest := domain.NewAdVideoRequest(input.UserAgent, input.Platform, input.Language, input.URL, input.PageTitle, *input.Referrer, *input.NetworkDownlink, *input.NetworkEffectiveType, input.IPAddress, input.Location, input.Hostname, input.City, input.Region, input.Country, input.Org, input.Postal, input.Timezone, input.VideoID, title, input.UserID, input.ClientID, &description, tags)
	ads, err := r.usecase.AdInputPort.GetAdsByVideoID(ctx, adVideoRequest)
	if err != nil {
		return nil, err
	}

	adsResponse := make([]*model.AdVideoPayload, 0)
	for _, ad := range ads {
		adsResponse = append(adsResponse, &model.AdVideoPayload{
			AdID:         ad.ID,
			AdURL:        ad.AdURL,
			Title:        ad.Title,
			Description:  ad.Description,
			ThumbnailURL: ad.ThumbnailURL,
			VideoURL:     ad.VideoURL,
		})
	}

	return adsResponse, nil
}
