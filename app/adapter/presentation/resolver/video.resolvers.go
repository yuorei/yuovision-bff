package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.46

import (
	"context"
	"fmt"
	"io"

	"github.com/yuorei/video-server/app/domain"
	model "github.com/yuorei/video-server/app/domain/models"
	"github.com/yuorei/video-server/graph/generated"
	"github.com/yuorei/video-server/lib"
)

// UploadVideo is the resolver for the UploadVideo field.
func (r *mutationResolver) UploadVideo(ctx context.Context, input model.UploadVideoInput) (*model.VideoPayload, error) {
	var thumbnailImage *io.ReadSeeker
	var thumbnailImageContentType string

	if input.ThumbnailImage != nil {
		thumbnailImage = &input.ThumbnailImage.File
		thumbnailImageContentType = input.ThumbnailImage.ContentType
	}

	tags := lib.PointersToStrings(input.Tags)

	videoID := domain.NewVideoID()
	uploadVideo := domain.NewUploadVideo(videoID, input.Video.File, input.Video.ContentType, thumbnailImage, thumbnailImageContentType, input.Title, input.Description, tags, input.IsPrivate, input.IsAdult, input.IsExternalCutout, input.IsAds)
	uploadedVideo, err := r.usecase.UploadVideo(ctx, uploadVideo)
	if err != nil {
		return nil, err
	}

	return &model.VideoPayload{
		ID:                uploadedVideo.ID,
		VideoURL:          uploadedVideo.VideoURL,
		ThumbnailImageURL: uploadedVideo.ThumbnailImageURL,
		Title:             uploadedVideo.Title,
		Description:       uploadedVideo.Description,
		Tags:              lib.StringsToPointers(uploadedVideo.Tags),
		IsPrivate:         uploadedVideo.IsPrivate,
		IsAdult:           uploadedVideo.IsAdult,
		IsExternalCutout:  uploadedVideo.IsExternalCutout,
		IsAd:              uploadedVideo.IsAd,
		CreatedAt:         uploadedVideo.CreatedAt.String(),
		UpdatedAt:         uploadedVideo.CreatedAt.String(),
		Uploader: &model.User{
			ID: uploadedVideo.UploaderID,
		},
	}, nil
}

// IncrementWatchCount is the resolver for the IncrementWatchCount field.
func (r *mutationResolver) IncrementWatchCount(ctx context.Context, input model.IncrementWatchCountInput) (*model.IncrementWatchCountPayload, error) {
	watchCount, err := r.usecase.IncrementWatchCount(ctx, input.VideoID, input.UserID)
	if err != nil {
		return nil, err
	}

	return &model.IncrementWatchCountPayload{
		WatchCount: watchCount,
	}, nil
}

// Videos is the resolver for the videos field.
func (r *queryResolver) Videos(ctx context.Context) ([]*model.Video, error) {
	videos, err := r.usecase.GetVideos(ctx)
	if err != nil {
		return nil, err
	}

	var result []*model.Video
	for _, video := range videos {
		result = append(result, &model.Video{
			ID:                video.ID,
			VideoURL:          video.VideoURL,
			ThumbnailImageURL: video.ThumbnailImageURL,
			Title:             video.Title,
			Description:       video.Description,
			Tags:              lib.StringsToPointers(video.Tags),
			IsPrivate:         video.IsPrivate,
			IsAdult:           video.IsAdult,
			IsExternalCutout:  video.IsExternalCutout,
			CreatedAt:         video.CreatedAt.String(),
			UpdatedAt:         video.CreatedAt.String(),
			Uploader: &model.User{
				ID: video.UploaderID,
			},
		})
	}

	return result, nil
}

// Video is the resolver for the video field.
func (r *queryResolver) Video(ctx context.Context, id string) (*model.Video, error) {
	video, err := r.usecase.GetVideo(ctx, id)
	if err != nil {
		return nil, err
	}
	return &model.Video{
		ID:                video.ID,
		VideoURL:          video.VideoURL,
		ThumbnailImageURL: video.ThumbnailImageURL,
		Title:             video.Title,
		Description:       video.Description,
		Tags:              lib.StringsToPointers(video.Tags),
		IsPrivate:         video.IsPrivate,
		IsAdult:           video.IsAdult,
		IsExternalCutout:  video.IsExternalCutout,
		IsAd:              video.IsAd,
		Ads:               nil,
		CreatedAt:         video.CreatedAt.String(),
		UpdatedAt:         video.CreatedAt.String(),
		Uploader: &model.User{
			ID: video.UploaderID,
		},
	}, nil
}

// WatchCount is the resolver for the watchCount field.
func (r *queryResolver) WatchCount(ctx context.Context, videoID string) (int, error) {
	watchCount, err := r.usecase.GetWatchCount(ctx, videoID)
	if err != nil {
		return 0, err
	}
	return watchCount, nil
}

// CutVideo is the resolver for the cutVideo field.
func (r *queryResolver) CutVideo(ctx context.Context, cutVideoInput model.CutVideoInput) (*model.CutVideoPayload, error) {
	cutVideoURL, err := r.usecase.CutVideo(ctx, cutVideoInput.VideoID, cutVideoInput.StartTime, cutVideoInput.EndTime)
	if err != nil {
		return nil, err
	}
	return &model.CutVideoPayload{
		CutVideoURL: cutVideoURL,
	}, nil
}

// ID is the resolver for the id field.
func (r *videoResolver) ID(ctx context.Context, obj *model.Video) (string, error) {
	return obj.ID, nil
}

// Ads is the resolver for the Ads field.
func (r *videoResolver) Ads(ctx context.Context, obj *model.Video) ([]*model.Ad, error) {
	panic(fmt.Errorf("not implemented: Ads - Ads"))
}

// Uploader is the resolver for the uploader field.
func (r *videoResolver) Uploader(ctx context.Context, obj *model.Video) (*model.User, error) {
	user, err := r.usecase.GetUser(ctx, obj.Uploader.ID)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:                  obj.Uploader.ID,
		Name:                user.Name,
		ProfileImageURL:     user.ProfileImageURL,
		Subscribechannelids: user.Subscribechannelids,
		IsSubscribed:        user.IsSubscribed,
		Role:                model.Role(user.Role),
	}, nil
}

// ID is the resolver for the id field.
func (r *videoPayloadResolver) ID(ctx context.Context, obj *model.VideoPayload) (string, error) {
	return obj.ID, nil
}

// Ads is the resolver for the Ads field.
func (r *videoPayloadResolver) Ads(ctx context.Context, obj *model.VideoPayload) ([]*model.Ad, error) {
	panic(fmt.Errorf("not implemented: Ads - Ads"))
}

// Uploader is the resolver for the uploader field.
func (r *videoPayloadResolver) Uploader(ctx context.Context, obj *model.VideoPayload) (*model.User, error) {
	user, err := r.usecase.GetUser(ctx, obj.Uploader.ID)
	if err != nil {
		return nil, err
	}
	return &model.User{
		ID:                  obj.Uploader.ID,
		Name:                user.Name,
		ProfileImageURL:     user.ProfileImageURL,
		Subscribechannelids: user.Subscribechannelids,
		IsSubscribed:        user.IsSubscribed,
		Role:                model.Role(user.Role),
	}, nil
}

// Video returns generated.VideoResolver implementation.
func (r *Resolver) Video() generated.VideoResolver { return &videoResolver{r} }

// VideoPayload returns generated.VideoPayloadResolver implementation.
func (r *Resolver) VideoPayload() generated.VideoPayloadResolver { return &videoPayloadResolver{r} }

type videoResolver struct{ *Resolver }
type videoPayloadResolver struct{ *Resolver }
